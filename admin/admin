#!/usr/bin/env node

'use strict';

var assert = require('assert'),
    async = require('async'),
    execSync = require('child_process').execSync,
    fs = require('fs'),
    https = require('https'),
    os = require('os'),
    path = require('path'),
    program = require('commander'),
    readlineSync = require('readline-sync'),
    spawn = require('child_process').spawn,
    SshClient = require('ssh2').Client,
    superagent = require('superagent'),
    util = require('util');

require('colors');

var SSH = 'root@%s -tt -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o ConnectTimeout=10 -i %s';
var sshKeyPath = path.join(process.env.HOME, '/.ssh/id_rsa_yellowtent');

if (!fs.existsSync(sshKeyPath)) exit('Unable to find ssh key path. Searching for ' + sshKeyPath);

// Allow self signed certs!
process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';

function exit(error) {
    if (error) console.log(error);
    process.exit(error ? 1 : 0);
}

function triggerBackup(ip, callback) {
    assert.strictEqual(typeof ip, 'string');
    assert.strictEqual(typeof callback, 'function');

    console.log('Trigger backup on %s'.bold, ip.cyan);

    var options = {
        hostname: ip,
        port: 886,
        path: '/api/v1/installer/backup',
        method: 'POST',
        key: fs.readFileSync(path.join(__dirname, '../../keys/installer/server.key')),
        cert: fs.readFileSync(path.join(__dirname, '../../keys/installer/server.crt')),
        ca: fs.readFileSync(path.join(__dirname, '../../keys/installer_ca/ca.crt')),
        rejectUnauthorized: false
    };

    var req = https.request(options, function (res) {
        res.setEncoding('utf8');
        res.on('data', function (chunk) {
            process.stdout.write(chunk);
        });
    });

    req.on('end', function () {
        callback();
    });

    req.on('error', function (error) {
        callback(error);
    });

    req.end();
}

function sshExec(ip, cmds) {
    var privateKey = path.join(process.env.HOME, '.ssh/id_rsa_yellowtent');
    if (!fs.existsSync(privateKey)) exit('cannot find private key');

    var sshClient = new SshClient();
    sshClient.connect({
        host: ip,
        port: 22,
        username: 'root',
        privateKey: fs.readFileSync(privateKey)
    });
    sshClient.on('ready', function () {
        console.log('connected');

        async.eachSeries(cmds, function (cmd, iteratorDone) {
            console.log(cmd.cmd.yellow);

            sshClient.exec(cmd.cmd, function(err, stream) {
                if (err) exit(err.message);

                if (cmd.stdin) cmd.stdin.pipe(stream);
                stream.pipe(process.stdout);
                stream.on('close', function () {
                    iteratorDone();
                });
            });
        }, function seriesDone(error) {
            if (error) exit(error.message);

            console.log('Done patching'.green);
            sshClient.end();
        });
    });
    sshClient.on('error', function (error) {
        exit(error.message);
    });
    sshClient.on('exit', function (exitCode) {
        console.log('exit');
        process.exit(exitCode);
    });
}

function hotfixCloudron(ip, code) {
    var CMDS = [
        { cmd: 'systemctl stop cloudron.target' },
        { cmd: 'rm -rf /home/yellowtent/box/* /home/yellowtent/box/.*' },
        { cmd: 'tar zxf - -C /home/yellowtent/box', stdin: fs.createReadStream(code) },
        { cmd: 'cd /home/yellowtent/box && npm rebuild' },
        { cmd: 'chown -R yellowtent.yellowtent /home/yellowtent/box' },
        { cmd: 'sed -e "s/restoreUrl/_restoreUrl/" -i /home/yellowtent/setup_start.sh' }, // do not restore
        { cmd: '/home/yellowtent/setup_start.sh' } // ensure db-migrate runs as well
    ];

    sshExec(ip, CMDS);
}

function hotfix(ip, options) {
    var code;

    if (!options.code) {
        var answer = readlineSync.question('Create a tarball from repo (y/n)? ');
        if (answer !== 'y') return exit();
        code = os.tmpdir() + '/boxtarball.tar.gz';
        execSync(path.join(__dirname, '../images/createBoxTarball --output ' + code + ' --no-upload'), { stdio: [ null, process.stdout, process.stderr ] });
    } else {
        code = options.code;
    }

    hotfixCloudron(ip, code);
}

function ssh(ip) {
    console.log('Ssh into %s'.bold, ip.cyan);

    var sshClient = spawn('ssh', util.format(SSH, ip, sshKeyPath).split(' '));
    sshClient.on('exit', exit);
    sshClient.on('error', exit);

    process.stdin.setEncoding('utf8');
    process.stdin.setRawMode(true);

    process.stdin.pipe(sshClient.stdin);
    sshClient.stdout.pipe(process.stdout);
    sshClient.stderr.pipe(process.stderr);

    process.stdin.resume();
}

function waitForBackup(ip) {
    superagent.get('https://' + ip + '/api/v1/cloudron/progress').get(function (error, result) {
        if (error) return exit(error);

        console.dir(result);
    });
}

function backup(ip) {
    triggerBackup(ip, function (error) {
        if (error) return exit(error);

        setTimeout(waitForBackup.bind(null, ip), 3000);
    });
}

// entry point
program.version('0.1.0');

program.command('ssh')
    .description('SSH to cloudron')
    .action(ssh);

program.command('hotfix')
    .description('Hotfix a cloudron')
    .option('--code <code>', 'Code tarball')
    .action(hotfix);

program.command('backup')
    .description('Backup a cloudron')
    .action(backup);

program.parse(process.argv);

if (!process.argv.slice(2).length) {
    program.outputHelp();
} else { // https://github.com/tj/commander.js/issues/338
    var knownCommand = program.commands.some(function (command) { return command._name === process.argv[2]; });
    if (!knownCommand) {
        console.error('Unknown command: ' + process.argv[2]);
        process.exit(1);
    }
}
